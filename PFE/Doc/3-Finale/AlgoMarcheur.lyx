#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass amsbook
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\language french
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Chapter
Algorithme du marcheur
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Au terme de notre étude sur l'existant et l'état de l'art, il nous est apparue
 que le développement d'un outils adapté au problème spécifique nous semblerait
 nécessaire.
 En effet le développement d'un modèle entier parait plus réalisable, à
 l'heure d'aujourd'hui, que l'adaptation d'un outils.
 
\end_layout

\begin_layout Standard
Pour résumer nous allons détailler le modèle que nous nous proposons de
 développer par la suite.
 Le modèle du marcheur
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Le nom 
\begin_inset Quotes fld
\end_inset

modèle du marcheur
\begin_inset Quotes frd
\end_inset

 est un clin d'œil à la 
\begin_inset Quotes fld
\end_inset

marche de l'ivrogne
\begin_inset Quotes frd
\end_inset

 qui est un modèle utilisé dans la thermodynamique et le mouvement brownien.
 
\end_layout

\end_inset

, ce modèle permet dans un premier temps de déterminer un indice de risque
 pour les pièces (
\begin_inset Formula $W@F$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Wafer at Risk
\end_layout

\end_inset

).
 Dans un deuxième temps de se servir de ça pour remonter aux pièces impactées.
 
\end_layout

\begin_layout Standard
L'idée de départ est assez simple, on se propose de regarder la probabilité
 d'un marcheur dans une ville d'être agressé dans une ville.
 
\end_layout

\begin_layout Section
Hypothèses
\end_layout

\begin_layout Standard
Afin de rendre le propos le plus claire possible nous allons poser toutes
 les hypothèses nécessaires au développement de l'algorithme.
\end_layout

\begin_layout Itemize
Un marcheur (produit) augmente sa 
\begin_inset Quotes fld
\end_inset

chance
\begin_inset Quotes frd
\end_inset

 d'être blessé (défectueux) au fur et à mesure qu'il se ballade dans la
 ville (Traverse beaucoup d'atelier).
\end_layout

\begin_layout Itemize
Le marcheur qui traverse des quartiers dangereux (Machine de production)
 à plus de chance d'être blessé dans un quartier dangereux.
\end_layout

\begin_layout Itemize
Propriété du quartier (Machine de production) 
\end_layout

\begin_deeper
\begin_layout Itemize
Le taux de criminalité augmente linéairement.
\end_layout

\begin_layout Itemize
La criminalité augmente en fonction du nombre de marcheurs qui traverse
 le quartier.
\end_layout

\begin_layout Itemize
La criminalité est remise à un niveau seuil quand la police passe.
 (Tache qualité)
\end_layout

\begin_layout Itemize
La criminalité est remise à un seuil si la santé du marcheur est bonne en
 sortant du quartier.
 On s'assure de la santé d'un marcheur en faisant passer un médecin (Mesure
 métrologique).
 Si la santé du marcheur est bonne, cela veut dire que la criminalité a
 été sur-évalué et il convient de la diminuer.
 
\end_layout

\end_deeper
\begin_layout Itemize
Le contrôle de la santé d'un marcheur donne de l'information uniquement
 sur le dernier quartier vu par le marcheur.
\end_layout

\begin_layout Itemize
Il y a trois type de marcheur, un petit, moyen et un grand (technologie
 logique, mémoire et mixte)
\end_layout

\begin_deeper
\begin_layout Itemize
Plus un marcheur est petit plus il aura de chance d'être agressé.
 
\end_layout

\end_deeper
\begin_layout Itemize
On formalise le problème : 
\begin_inset Formula \[
W@F=1-\prod_{1}^{N}\left(F_{Machine}[i]\times F_{Produit}\right)\]

\end_inset


\end_layout

\begin_layout Section
L'agorithme
\end_layout

\begin_layout Standard
On définit différents niveaux de complexité à notre algorithme, pour chaque
 niveau de complexité nous détaillerons les différences.
 Il est à noter que tous ces calculs sont donné pour le calcul du 
\begin_inset Formula $W@F$
\end_inset

 d'un seul marcheur (produit).
 On fera tourner cette algorithme dans une boucle pour comparer les 
\end_layout

\begin_layout Subsection
Niveau 0 : Modele simple
\end_layout

\begin_layout Standard
On suppose que les machines ont une fiabilité 
\begin_inset Formula $F=0,5=50\%$
\end_inset

, il y a 
\begin_inset Formula $N$
\end_inset

 étapes de fabrication, et 
\begin_inset Formula $W@F_{produit}$
\end_inset

 est la probabilité du produit d'être défectueux
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Probabilité au marcheur d'être blessé.
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
pour 
\begin_inset Formula $i$
\end_inset

, de 
\begin_inset Formula $1$
\end_inset

 à 
\begin_inset Formula $N$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $F_{Produit}=F_{Produit}\times F$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Fin Pour
\end_layout

\begin_layout Itemize
\begin_inset Formula $W@F=1-F_{Produit}$
\end_inset


\end_layout

\begin_layout Subsection
Niveau 1 : Modèle des quartiers
\end_layout

\begin_layout Standard
On suppose maintenant que la fiabilité est différente sur chaque machine
 
\begin_inset Formula $F_{Machine[i]}$
\end_inset


\end_layout

\begin_layout Itemize
pour 
\begin_inset Formula $i$
\end_inset

, de 
\begin_inset Formula $1$
\end_inset

 à 
\begin_inset Formula $N$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $F_{Produit}=F_{Produit}\times F_{Machine[i]}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Fin Pour
\end_layout

\begin_layout Itemize
\begin_inset Formula $W@F=1-F_{Produit}$
\end_inset


\end_layout

\begin_layout Subsection
Niveau 2 : Modèle des quartiers avec criminalité croissante
\end_layout

\begin_layout Standard
On suppose maintenant que la fiabilité est différente sur chaque machine
 et décroit linéairement.
\end_layout

\begin_layout Standard
\begin_inset Formula $F_{MachineTemps[i]}=1-\left(\lambda_{Machine}\times T_{Machine}\right)$
\end_inset

, avec 
\begin_inset Formula $T_{Machine}$
\end_inset

 est le temps du dernière contrôle de la machine et 
\begin_inset Formula $\lambda_{Machine}$
\end_inset

 est le coefficient de décroissance de la fiabilité.
 
\end_layout

\begin_layout Standard
On a aussi 
\begin_inset Formula $F_{MachineProduits[i]}=1-\left(\lambda_{Machine}\times N_{Produit}\right)$
\end_inset

 avec 
\begin_inset Formula $N_{Produit}$
\end_inset

 le nombre de produits passés sur la machine.
\end_layout

\begin_layout Standard
Nous prendrons pour 
\begin_inset Formula $F_{Machine}=\min\left(F_{MachineTemps[i]},F_{MachineProduits[i]}\right)$
\end_inset


\end_layout

\begin_layout Standard
Nous verrons à l'usage ce qui est le plus cohérent à l'usage.
\end_layout

\begin_layout Itemize
pour 
\begin_inset Formula $i$
\end_inset

, de 
\begin_inset Formula $1$
\end_inset

à 
\begin_inset Formula $N$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $F_{Produit}=F_{Produit}\times F_{Machine[i]}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Fin Pour
\end_layout

\begin_layout Itemize
\begin_inset Formula $W@F=1-F_{Produit}$
\end_inset


\end_layout

\begin_layout Subsection
Niveau 3 : Modèle du marcheur inhomogène 
\end_layout

\begin_layout Standard
On suppose maintenant que le type de marcheur (la technologie), est plus
 suceptible d'être bléssé suivant son type intrinsèque
\end_layout

\begin_layout Standard
\begin_inset Formula $F_{Produit}=\beta_{type}\times F_{Produit}$
\end_inset


\end_layout

\begin_layout Standard
avec 
\begin_inset Formula $\beta_{type}=\beta_{petit},\beta_{moyen},\beta_{grand}$
\end_inset

comme dans la vie réelle un grand aura moins de chance d'être agressé qu'un
 petit.
 
\end_layout

\begin_layout Standard
Afin de faire le parallèle avec les technologie :
\end_layout

\begin_layout Description
\begin_inset Formula $\beta_{grand}$
\end_inset

 correspond aux technologies de logique, qui sont les plus faciles à mettre
 en oeuvre
\end_layout

\begin_layout Description
\begin_inset Formula $\beta_{moyen}$
\end_inset

 correspond aux technologies de mémoires, qui sont légèrement plus compliqués
 
\end_layout

\begin_layout Description
\begin_inset Formula $\beta_{petit}$
\end_inset

 correspond aux technologies mixtes
\begin_inset Foot
status open

\begin_layout Plain Layout
mémoire et logique
\end_layout

\end_inset

 qui sont les technologies les plus compliqués à mettre en place.
 
\end_layout

\begin_layout Standard
Le calcul s'effectue de la même manière ensuite, on introduira simplement
 le nouveau 
\begin_inset Formula $F_{Produit}$
\end_inset


\end_layout

\begin_layout Section
Code de l'algorithme
\end_layout

\begin_layout Standard
Dans un soucis de performance (vu la quantité d'information à traiter) nous
 allons développer notre code en C
\begin_inset Note Note
status open

\begin_layout Plain Layout
Je sais c'est pas ce qu'on a dit la dernière fois (JAVA) mais pour faire
 du procédurale avec un nombre important de données le C est plus adapté.
 
\end_layout

\end_inset

en effet le nombre de données à traiter est important, et la structure de
 l'algorithme nous incite à utiliser ce type de language.
 En effet le C est un language simple, et proche de la machine, ce qui se
 traduit par de haute performances.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "../../Code/Marcheur.c"
lstparams "caption={Modele simple : niveau 0},label={Algo-niveau-0}"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
L'inclusion du code en C est mise à titre de test
\end_layout

\end_inset


\end_layout

\begin_layout Section
Traitement des données
\end_layout

\begin_layout Subsection
Analyse des données
\end_layout

\begin_layout Standard
Afin de tester notre algorithme nous avons récupéré un fichier de données
 de 
\emph on
STElectronics
\emph default
, afin de bien comprendre ces données nous allons les analyser.
 
\end_layout

\begin_layout Standard
On distingue différents champs de données : 
\end_layout

\begin_layout Description
taskID
\begin_inset space ~
\end_inset

(Champs
\begin_inset space ~
\end_inset

Vide) Le premier champs vide est le numéro de la tâche, chaque tâche est
 numéroté de manière unique.
 
\end_layout

\begin_layout Description
Date Il s'agit de la date à laquelle l'évenement étudié a eu lieux.
 Il est à noter que notre fichier de données repose sur 15 jours de productions,
 le temps est donné en secondes.
\end_layout

\begin_deeper
\begin_layout Itemize
Le champs de la date est composé de 
\begin_inset Formula $14$
\end_inset

 chiffres, exemple : 
\begin_inset Formula $20101010162720$
\end_inset


\end_layout

\begin_layout Itemize
Les 4 premier chiffres représentent l'année ici 
\begin_inset Formula $2010$
\end_inset

 est l'année 
\end_layout

\begin_layout Itemize
Les 2 chiffres suivants représentent le mois, ici 
\begin_inset Formula $10$
\end_inset

 donc octobre
\end_layout

\begin_layout Itemize
Les 2 chiffres suvants représentent le jour, ici 
\begin_inset Formula $10$
\end_inset


\end_layout

\begin_layout Itemize
Les 6 chiffres suivants représentent l'heure, ici 
\begin_inset Formula $162720$
\end_inset

 qui donne 
\begin_inset Formula $16$
\end_inset

 heure 
\begin_inset Formula $27$
\end_inset

 min et 
\begin_inset Formula $20$
\end_inset

 secondes 
\end_layout

\end_deeper
\begin_layout Description
Lot
\begin_inset space ~
\end_inset

(batch) Il s'agit du numéro du lot, impacté par la tâche.
 Dans le cas où ce champ est vide, cela veut dire que la machine ne traite
 pas de produit mais qu'on effectue une tâche qualité sur la machine.
 
\end_layout

\begin_layout Description
Oper
\begin_inset space ~
\end_inset

(operation) Ce champs qualifie le type d'opération effectués sur le lot
 
\end_layout

\begin_layout Description
Nbr
\begin_inset space ~
\end_inset

(quantity) Représente le nombre de wafers concernés par un evenement de
 process, c'est-à-dire le nombre de plaques passées dans la machine.
\end_layout

\begin_layout Description
Event Permet de qualifier le type d'évenement, dans notre exemple nous avons
 trois types d'évenements différents :
\end_layout

\begin_deeper
\begin_layout Description
PRP représente une étape de fabrication du produit
\end_layout

\begin_layout Description
MSL indique une mesure effectuée sur un lot
\end_layout

\begin_layout Description
MSE indique une mesure réalisée sur un équipement (tâche de qualité, ou
 
\begin_inset Quotes fld
\end_inset

TQ
\begin_inset Quotes frd
\end_inset

)
\end_layout

\end_deeper
\begin_layout Description
Tech
\begin_inset space ~
\end_inset

(technology) Représente la technologie, nous disposons de cinq technologies
 différentes.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quel technologie est la plus compliqué ?
\end_layout

\end_inset


\end_layout

\begin_layout Description
Eqpt
\begin_inset space ~
\end_inset

(workstationID) Représente le numéro de l'équipement, chaque équipement
 est représenté par un identifiant unique.
 
\end_layout

\begin_layout Subsection
Structure des données
\end_layout

\begin_layout Standard
Afin d'utiliser les données au mieux, nous allons organiser les données
 sous forme de la structure suivante.
 
\end_layout

\begin_layout Standard
Dans un premier temps nous allons organiser les données par produits, machines
 et ordres.
 Dans le détail 
\end_layout

\begin_layout Description
Date structure qui organise une date
\end_layout

\begin_deeper
\begin_layout Description
Entier
\begin_inset space ~
\end_inset

year 
\end_layout

\begin_layout Description
Entier
\begin_inset space ~
\end_inset

month
\end_layout

\begin_layout Description
Entier
\begin_inset space ~
\end_inset

day
\end_layout

\begin_layout Description
Entier
\begin_inset space ~
\end_inset

hour
\end_layout

\begin_layout Description
Entier
\begin_inset space ~
\end_inset

minutes
\end_layout

\begin_layout Description
Entier
\begin_inset space ~
\end_inset

secondes
\end_layout

\end_deeper
\begin_layout Description
Traçabilité structure de la mémoire des événements 
\end_layout

\begin_deeper
\begin_layout Description
Entier
\begin_inset space ~
\end_inset

Tâche numéro de tâche
\end_layout

\begin_layout Description
Date
\begin_inset space ~
\end_inset

date Donne la date de chaque tâche.
\end_layout

\begin_layout Description
Charactere
\begin_inset space ~
\end_inset

Type Précise le type de tâche 
\end_layout

\end_deeper
\begin_layout Description
Machine Qualifie la ressource qui usine le procédé
\end_layout

\begin_deeper
\begin_layout Description
Tableau
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

traçabilité 
\begin_inset Quotes fld
\end_inset

mémoire
\begin_inset Quotes frd
\end_inset

 de la ressource, c'est elle qui stocke les tâches se produisant sur la
 machine (La structure de taçabilité sera détaillé un peu plus loin)
\end_layout

\begin_layout Description
Entier
\begin_inset space ~
\end_inset

NbrElement nombre d'élement de la traçabilité (en effet le C ne donnant
 pas les tailles de tableaux facilement, il s'agit là d'une astuce pour
 contourner le problème)
\end_layout

\begin_layout Description
Charactere
\begin_inset space ~
\end_inset

Nom Le nom de la machine
\end_layout

\end_deeper
\begin_layout Description
Produit
\end_layout

\begin_deeper
\begin_layout Description
Tableau
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

traçabilité 
\begin_inset Quotes fld
\end_inset

mémoire
\begin_inset Quotes frd
\end_inset

 du produit, c'est elle qui stocke les tâches se produisant sur la machine.
\end_layout

\begin_layout Description
Entier
\begin_inset space ~
\end_inset

NbrElement nombre d'élement de la traçabilité (en effet le C ne donnant
 pas les tailles de tableaux facilement, il s'agit là d'une astuce pour
 contourner le problème)
\end_layout

\begin_layout Description
Charactere
\begin_inset space ~
\end_inset

Nom Le nom du produit
\end_layout

\begin_layout Description
Entier
\begin_inset space ~
\end_inset

Technologie Permet de définir 
\end_layout

\end_deeper
\begin_layout Standard
Cette structure nous permet d'organiser les données de manière logique,
 et permet de piocher facilement dans les données.
 
\end_layout

\begin_layout Section
Spécification du code
\end_layout

\begin_layout Subsection
Marcheur 
\end_layout

\begin_layout Standard
Contient l'algorithme a partir, il effectue le calcule 
\end_layout

\begin_layout Subsection
Lecture de fichier (LoadFile)
\end_layout

\begin_layout Standard
Nous organisons notre lecture de fichier de façon à ranger les informations
 dans la bonne structure.
\end_layout

\begin_layout Standard
On définit une classe qui lit les fichiers et instancie les objets en conséquent.
\end_layout

\end_body
\end_document
